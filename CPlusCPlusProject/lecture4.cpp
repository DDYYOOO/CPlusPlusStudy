/*
	작성자 : 이동윤
	작성일 : 2024-08-13
	학습 목표 : 첫 클래스 선언, 함수 오버로딩과 생성자에 대한 이해
*/

#include"lectures.h"

/*
  클래스 선언
  클래스(class) : 객체 - 프로그래밍 언어로 세상에 존재하는 모든 대상을 표현하는 것

*/

// 1. 객체가 함수를 실행하는 것이 더 보기에 직관적이다
// struct 구조체 함수를 내부에 포함할 수 없다
// 클래스 내부에 함수를 포함해서 사용을 할 수 있다

class Pet
{
private:
	char name[30];
	int happy;
	int hungry;
	int sleep;

public:
	Pet();  // 이 클래스 안에 있는 데이터들의 디폴트 값
	Pet(int happy, int hungry);
	Pet(int sleep, int happy, int hungry);
	void Play();
	void Feed();
	void ShowStatus();
	void MakeDog();

};

// 범위 지정자 이름공간::  // 네임 스페이스 안에 있는 함수를 사용
// 클래스::함수이름   // 클래스 안에 있는 함수를 사용

Pet::Pet()
{
	strcpy_s(name, 30, "뽀삐");
	happy = 100;
	hungry = 100;
}

Pet::Pet(int happy, int hungry)
{
	std::cin >> name;
	this->happy = happy;
	this->hungry = hungry;
}

Pet::Pet(int _sleep, int _happy, int _hungry)
{
	sleep = _sleep;
	happy = _happy;
}

void Pet::Play()
{
	happy += 10;
	hungry -= 5;
}

void Pet::Feed()
{
	happy += 5;
	hungry += 10;
}

void Pet::ShowStatus()
{
	std::cout << "펫의 이름 : " << name << std::endl;
	std::cout << "펫의 행복도 : " << happy << std::endl;
	std::cout << "펫의 허기도 : " << hungry << std::endl;
}
/// <summary>
/// Dog의 초기화 함수이므로 반드시 변수의 선언과 함께 사용
/// </summary>
void Pet::MakeDog()
{
	
}

/*
  함수 오버로딩(overloading) : 과적하다, 과부하에 걸리게 하다

  void Add(int a, int b) { a + b; }
  void Add(float a, float b) { a + b; }
  void Add(double a, double b) { a + b; }
  void Add(char a, char b) { a + b; }

*/

/*
  함수 오버로딩 사용 시 주의 사항
  1. 컴파일러가 함수를 구별하는 방식은 (1) 함수의 이름 (2) 인자의 데이터 타입
	 void Add(int a);
	 void Add(int b);
	 void Add();
  
  2. void Print(int x);
     void Print(char x);
	 void Print(double x);

*/

void Print(int x)
{
	std::cout << "int x : " << x << std::endl;
}
void Print(char x)
{
	std::cout << "char x : " << x << std::endl;
}
void Print(double x)
{
	std::cout << "double x : " << x << std::endl;
}
/*
  클래스 생성자 : 클래스를 선언한 후 초기화 함수를 강제로 호출시키는 기능

  Dog dog1;  // default 생성자가 호출

  default : 숫자 데이터들은 0으로 초기화, 주소 데이터들은 NULL(C++에서는 nullPtr);

*/

void lecture4()
{
	// Play();		C언어 함수 호출 방법x
	//Dog::Play();	특별한 문법(static)을 사용하지 않는 이상 사용x

	// 생성자, 구조체 처음 변수를 선언하고 나서 데이터를 초기화하지 않으면 이상한 데이터가 출력되는 문제가 있다
	// MakeDog() : 초기화 함수를 반드시 먼저 실행 해줘야 함
	Pet dog1;
	dog1.MakeDog();	// 문법적으로 반드시 강제하는 기능이 생성자
	dog1.ShowStatus();

	// case1. 함수 오버로딩에 인자를 만들어준 타입
	int a = 1;
	char b = 'b';
    double c = 1.1;
	Print(a);
	Print(b);
	Print(c);

	// case2. 함수 오버로딩에 없는 인자
	short s1 = 2;
	float f1 = 2.2f;
	Print(s1);
	Print(f1);

	// 함수의 이름은 존재하는데 데이터 타입은 없는 경우
	// 컴파일러가 어떻게 행동?
	// 1. 데이터 타입이 없으면 컴파일러는 형변환을 시도
	// 2. 명시적 형변환, 묵시적 형변환이 있는데. 위의 코드에서는 묵시적 형변환이 일어나고 있다
	// 3. 정수형 데이터 타입은 먼저 int형으로 변환을 시도하고 실수형 데이터 타입은 double형으로 변환을 시도하고 float으로 형변환을 시도
	// 4. 정수형 데이터 타입이 없을 경우 실수형 데이터 타입을 정수형으로 바꾸어서 형변환을 시도
	//    float, double -> 정수형 데이터 타입을 변환?
	//	  int를 받는 함수, char를 받는 함수 둘 중에 무엇을 선택해야 할 지 모르기 때문에 
	//    오버로드된 함수가 인스턴스 중 두 개 이상의 인수 목록과 일치합니다

	// 정리
	// 컴파일러는 우리가 알게 모르게 잘못된 코드도 정상적으로 처리하도록 실행 하고 있다
	// 1. 데이터 타입을 정의하지 않았는데 실행 됨 -> 타입이 오버로딩으로 정의되지 않았어도 사용이 가능
	// 2. 실수형 데이터 타입을 선언하지 않고 정수형 데이터 타입을 두 개 이상 선언했다. 

	// 생성자의 선언
	Pet dog2;		   // 디폴트 생성자 호출
	dog2.ShowStatus();
	Pet dog3 = Pet();  // 디폴트 생성자 호출
	dog3.ShowStatus();

	int doghappy;
	std::cin >> doghappy;
	int doghungry;
	std::cin >> doghungry;
	Pet dog4 = Pet(doghappy, doghungry);
	dog4.ShowStatus();

	// 아래 코드는 현재 문제가 있는 코드
	Pet dog5 = dog4;
	dog5.ShowStatus();

	Pet* dogs[100];
	dogs[0] = new Pet();

	dogs[1] = dogs[0];
	dogs[1]->ShowStatus();
	delete dogs[0];

}